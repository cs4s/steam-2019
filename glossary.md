---
layout: glossary
title: Coding & STEAM 2019 - Glossary
---

# Glossary

This page contains a list of definitions of key terms that will be used in the activities during this workshop.
We have split the definitions in this glossary into two main sections:

- **General Coding and Computational Thinking Terms:** these are terms that are not specific to a certain programming language (for example, Scratch)
- **Scratch Terms:** these are the terms that are specific to Scratch (although they may also be used in other, similar languages like [Snap!](http://snap.berkeley.edu/){:target="_blank"}).

We have tried to include many of the terms that are commonly used in the [Digital Technologies content descriptors](http://v7-5.australiancurriculum.edu.au/technologies/digital-technologies/curriculum/f-10?layout=1){:target="_blank"} in this glossary.
Let us know if you think there are terms commonly used that should be added to the glossary for future programs or if any of the definitions below could be improved.

## General Coding and Computational Thinking Terms

### Abstraction

**Abstraction** is one of the [Computational Practices](#computational-practice) identified by [Brenann and Resnick](http://web.media.mit.edu/~kbrennan/files/Brennan_Resnick_AERA2012_CT.pdf){:target="_blank"}.
In [Computer Science](#computer-science), **Abstraction** is the simplification of ideas that can be necessary when solving problems using [Computational Thinking](#computational-thinking).

A common example of **Abstraction** is the drawing of world maps, as these present information about different countries in a relatively simple way.
For more examples and an explanation of how **Abstraction** can be applied in Primary School [Coding](#coding) lessons, please see [this document from Barefoot Computing](https://barefootcas.org.uk/wp-content/uploads/2014/10/Abstraction-Concept-Barefoot-Computing.pdf){:target="_blank"}.

### Algorithm

An **Algorithm** is a precise and step-by-step procedure that is written for a computer to follow.
**Algorithms** are often compared to recipes, as recipes also involve detailed, step-by-step instructions.

For a more in-depth explanation of **Algorithms**, we recommend this page on the [BBC Bitesize website](https://www.bbc.com/education/guides/z22wwmn/revision){:target="_blank"}, which contains several examples of how **Algorithms** are used in a variety of areas (such as weather forecasting).

### Bitmap

A **Bitmap** image is one of the two types of images (the other type of images are [Vector](#vector) images). 
**Bitmap** images are made up of pixels in a grid and are often used for digital photos.

You may notice that when you zoom in on a **Bitmap** image, the image appears to be a poorer quality.
This is because when you zoom in on a **Bitmap** image or try to make it bigger, the pixels in the grid stretch and make the overall picture look blurred or low quality.
The Paint Editor in Scratch has the ability to create **Bitmap** and [Vector](#vector) images, which is explained on the [Scratch Wiki](https://en.scratch-wiki.info/wiki/Paint_Editor){:target="_blank"}.
You can learn more about **Bitmap** and [Vector](#vector) images and the differences between them from [this page about Encoding Images on the BBC Bitesize Website](https://www.bbc.com/education/guides/zqyrq6f/revision/1){:target="_blank"}.


### Boolean

A **Boolean** value can be either: *True* or *False*.
These are often used when creating [Conditionals](#conditionals) in programs.
An example of a **Boolean** block is shown below.

~~~
mouse down?
~~~
{: .language-scratch}

In Scratch, when the mouse is being clicked the block above will report *True*.

### Branching

See the definition for [Conditionals](#conditionals) below.

### Coding

In this program, we have defined **Coding** as: the act of writing instructions for a computer to follow, in some **Coding** language (for example: Scratch).

It's important to note that, if we think about **Coding** in terms of the definition above, that we need a combination of **Coding** and **Computational Thinking** to be able to instruct a computer to solve a problem.
Generally, *programming* and **Coding** are interchangeable terms: they usually both refer to the act of writing Code.

### Command

A **Command** is an instruction which we can give the computer to follow.
The computer will follow the **Command** exactly as we tell it to.

For example, we may have a robot which we can *Code* to navigate a maze.
A couple of the commands we could use to navigate the robot could be *move forward for 1 metre* and *turn right*.

### Computational Concept

According to [Brenann and Resnick](http://web.media.mit.edu/~kbrennan/files/Brennan_Resnick_AERA2012_CT.pdf){:target="_blank"}, **Computational Concepts** are *"the concepts designers 
employ as they program"*.
These concepts are essential to solving problems with computers, as they are combined when creating programs (in Scratch or any other [Coding](#coding) language).

The **Computational Concepts** are:

- [Sequences](#sequences)
- [Loops](#loops)
- [Parallelism](#parallelism)
- [Events](#events) 
- [Conditionals](#conditionals)
- [Operators](#operators)
- [Data](#data)

### Computational Perspective

According to [Brenann and Resnick](http://web.media.mit.edu/~kbrennan/files/Brennan_Resnick_AERA2012_CT.pdf){:target="_blank"}, **Computational Perspectives** are *"the perspectives designers form about the world around them and about themselves"*. 
When observing and interviewing students that had designed projects in Scratch, Brennan and Resnick found that the students' perspectives had shifted as a result of the process of creating computer programs.

The **Computational Perspectives** are:

- *Expressing:* when students recognise that they can create and express themselves through the creation of computer programs
- *Connecting:* when students using Scratch interact and learn from other students creating computer programs
- *Questioning:* when students use Scratch to help them understand technology and/or the world around them

### Computational Practice

According to [Brenann and Resnick](http://web.media.mit.edu/~kbrennan/files/Brennan_Resnick_AERA2012_CT.pdf){:target="_blank"}, **Computational Practices** are *"the practices designers develop as they 
program"*.

The **Computational Practices** are:

- *Being incremental and iterative*
- [Testing](#testing) and [Debugging](#debugging)
- *Reusing* and [Remixing](#remixing)
- [Abstracting](#abstraction) and [Modularizing](#modularisation)

### Computational Thinking

**Computational Thinking** is commonly referred to as the *"...thought processes involved in formulating problems and their solutions so that the solutions are represented in a form that can be effectively carried out by an information-processing agent [i.e. a Computer]."*

The meaning of **Computational Thinking** above is the definition given by [Jeanette Wing](https://www.cs.cmu.edu/link/research-notebook-computational-thinking-what-and-why){:target="_blank"}, which is one of the most common definitions of **Computational Thinking**. 
Wing argued that the thinking processes that Computer Scientists use when solving problems with computer programs could be developed separately to [Coding](#coding) skills and that some of these concepts (such as [Abstraction](#abstraction)) can be applied to solve problems in people's daily lives.

In the *Coding in Stage 3* program, we use the **Computational Thinking** framework developed by [Karen Brennan and Mitchell Resnick](http://web.media.mit.edu/~kbrennan/files/Brennan_Resnick_AERA2012_CT.pdf){:target="_blank"} to define **Computational Thinking**.
This definition has been developed by studying childrens as designers, who used Scratch to create projects such as: stories, animations and games.
Brennan and Resnick's **Computational Thinking** framework consists of three key dimensions:

- [Computational Concepts](#computational-concept): "the concepts designers employ as they program", such as [Loops](#loops) and [Conditionals](#conditionals) 
- [Computational Practices](#computational-practice): "the practices designers develop as they program", such as being *incremental and iterative*, [Testing](#testing) and [Debugging](#debugging).
- [Computational Perspectives](#computational-perspective): "the perspectives designers form about the world around them and about themselves", such as *expressing* themselves through creation of Scratch projects and *connecting* with other students through the Scratch community.

### Computer Science

Broadly, **Computer Science** is the study of what computers can do, how computers can be made to solve tasks faster and more effectively, and how humans can use computers to solve tasks in a variety of areas. 
There are several common misconceptions of **Computer Science**, including that it involves:

- Fixing computers or building computers
- *Coding* 8 hours a day
- Only working with other *programmers*

However, while some of these would be true for some **Computer Scientists**, it is not true for all of them.
Some **Computer Scientists** may not use computers much at all in their daily work and many *programmers* work with a variety of professionals (not just other *programmers*).

There are many diverse fields within the study of **Computer Science**.
Examples of some **Computer Science** fields, include those that:

- are very theoretical and involve a lot of Mathematics (for example: [Theoretical Computer Science](https://en.wikipedia.org/wiki/Theoretical_computer_science){:target="_blank"} and [Cryptography](https://en.wikipedia.org/wiki/Cryptography){:target="_blank"})
- have been a result of interdisciplinary collaboration between Computer Scientists and researchers from another field (for example: [Bioinformatics](https://en.wikipedia.org/wiki/Bioinformatics){:target="_blank"}, which combines Computer Science and Biology)
- are focused on building and maintaining large, secure and reliable *programs* (for example: [Software Engineering](https://en.wikipedia.org/wiki/Software_engineering){:target=_"blank"} and [Cybersecurity](https://en.wikipedia.org/wiki/Computer_security){:target="_blank"}.
- involve creating new ways for people to use computers or are concerned with understanding how people use computers (for example: [Human-Computer Interaction](https://en.wikipedia.org/wiki/Human%E2%80%93computer_interaction){:target="_blank"})

We recommend reading the [K-12 CS Framework's Defining Computer Science article](https://k12cs.org/defining-computer-science/){:target="_blank"} and the [Computer Science Field Guide](http://csfieldguide.org.nz/){:target="_blank"} for more information about what **Computer Science** is and the diverse fields it encompasses.

### Conditionals

**Conditionals** are another [Computational Concept](#computational-concept), which refer to the computer following different instructions based on different conditions.
In some cases, **Conditionals** are also referred to as *selection* or *branching*.
There are many examples of **Conditionals** in real life.
For example, say that you are hosting a barbecue and a friend has offered to buy the bread from the supermarket.
You have heard that there has been a shortage of loaves of bread in the local area and so you give them the following instructions:

- If there are loaves of bread at the supermarket, buy a loaf of bread
- If there's no loaves of bread left at the supermarket, buy 3 packs of breadrolls instead

This example is **Conditionals** because, depending on the condition (the availability of loaves of bread), different instructions will be followed.

In Scratch, examples of **Conditionals** block include the *if* and *if then else* blocks.
In the blocks below, if a [Sprite](#sprite) touches a "Lightning Bolt" [Sprite](#sprite) it will disappear:

~~~
when gf clicked
	forever
		if <touching [Lightning Bolt v] ?> then
			hide
		end
	end
~~~
{: .language-scratch}

### Data

**Data** is another [Computational Concept](#computational-concept).
As described by [Brennan and Resnick](http://web.media.mit.edu/~kbrennan/files/Brennan_Resnick_AERA2012_CT.pdf){:target="_blank"}, "Data involves storing, retrieving, and updating values."
There are two main ways of dealing with **Data** in Scratch: [Variables](#variables) and *Lists*.

One example of a common use of **Data** in Scratch is the use of [Variables](#variables) for keeping track of a player's score in a game.
In the blocks below, when a [Sprite](#sprite) touches a Star [Sprite](#sprite) the player's score will increase by 1.

~~~
when gf clicked
	set [score v] to [0]
	forever
		if <touching [Star v] ?> then
			change [score v] by (1)
		end
	end
~~~
{: .language-scratch}

### Debugging

**Debugging** is the process of finding the causes of and fixing problems in *programs*.
For example, a student may write a Scratch *program* where they move a Cat around a canvas.
The student might find that the program is not working as expected.
For example, they want the Cat to move to the right but it is moving to the left instead.
When the student tries to work out what is causing the Cat to move the wrong way, they are **Debugging**.

### Events

**Events** are another [Computational Concept](#computational-concept), which refers to the way that actions in [Programs](#program) can be triggered by other commands and actions.
In Scratch, many of the **Events** are [Hat Blocks](#hat-blocks), which are in the **Events** section of the blocks, such as the example blocks given below:

~~~
when gf clicked

when [space v] key pressed

when this sprite clicked
~~~
{: .language-scratch}

Another example of triggering an action with **Events** in Scratch includes making a [Sprite](#sprite) disappear when it is clicked.
This is shown in the example blocks below:

~~~
when this sprite clicked
	hide
~~~
{: .language-scratch}

### Invalid Input

**Invalid input** is a term for *user input* that is put into a system which is nonsensical or that causes the system to act in an unexpected way.
For example, you might buy a book on an online store and, when filling in your shipping details, accidentally put your email address in the form where your home address should go.
The system would then tell you that you have made an error (*invalid input*) when filling out the form.

### Iteration

See the definition for [Repetition](#repetition) below.

### Logical Reasoning

**Logical reasoning** means reasoning correctly and systematically, and applying rules in a systematic way to complete a task (for example: applying knowledge about what each block in Scratch does to predict the outcome of a script).

### Loops

**Loops** are a [Computational Concept](#computational-concept), which refers to the way computers can follow instructions over and over again (in a loop).
**Loops** are also sometimes referred to as *iteration* and *repetition*.

Computers are very good at repeating actions, whether you want them to repeat something two times, one hundred times, or even to have them repeat something over and over forever.
There are many examples of **Loops** in real life, as well as in *Code*. 
For example, when you swim 10 laps in a pool, you are repeating the lap 10 times. 
You would also be repeating the actions that make up the stroke (for example: freestyle) over and over as you swam the lap.

In Scratch, examples of **Loops** include the *repeat* and *forever* blocks.
In the example blocks below, when the space key is pressed a [Sprite](#sprite) will continuously rotate clockwise, until you stop the program.

~~~
when [space v] key pressed
	forever
		turn cw (45) degrees
	end
~~~
{: .language-scratch}

### Modularisation

**Modularisation** is one of the [Computational Practices](#computational-practice) identified by [Brenann and Resnick](http://web.media.mit.edu/~kbrennan/files/Brennan_Resnick_AERA2012_CT.pdf){:target="_blank"}. 
In [Computer Science](#computer-science), **Modularisation** is the splitting of programs into smaller "modules" or smaller programs. 
By using **Modularisation**, you can break complex problems into simpler parts to make them more manageable.

**Modularisation** is also commonly referred to as *Decomposition*. 
You can read about examples of *Decomposition* and how these can apply to problem solving in Primary School [Coding](#coding) in this document created by [Barefoot Computing](https://barefootcas.org.uk/wp-content/uploads/2014/09/Decomposition-Concept-Barefoot-Computing.pdf){:target="_blank"}

### Nested Conditionals

**Nested Conditionals** (also known as *Nested Branching*) involves having one or more [Conditionals](#conditionals) block (for example: an *if then else* block in Scratch) inside another [Conditionals](#conditionals) block.

An example of the use of **Nested Conditionals** in Scratch is shown in the example below. 
If the [User Input](#user-input) to the question: "What's your age?" is *25*, the [Sprite](#sprite) will say: *"You're the right age to play this game!"*.

~~~
when gf clicked
	ask [What's your age?] and wait
	if <(answer) < [10]> then
		if <(answer) > [100]> then
			say [You're too old to play this game!] for (2) secs
		else
			say [You're the right age to play this game!] for (2) secs
		end
	else
		say [You're too young to play this game!] for (2) secs
	end
~~~
{: .language-scratch}


### Nested Loops

**Nested Loops** (also known as *Nested Repetition*) involves having one or more [Loop](#loops) blocks (for example: a *repeat* block in Scratch) inside another [Loop](#loops) block.

An example of the use of **Nested Loops** is shown in the example below.

~~~
when [space v] key pressed
	repeat (3)
		play drum (1 v) for (1) beats
		repeat (2)
			play note (60 v) for (1) beats
			play note (58 v) for (1) beats
			play note (56 v) for (1) beats
		end
	end
~~~
{: .language-scratch}

After pressing the space key, the following will happen:

1. A snare drum noise will be played
2. A note will be played (60)
3. Another note will be played (58)
4. Another note will be played (56)
5. Another note will be played (60)
6. Another note will be played (58)
7. Another note will be played (56)

Then, the steps above will repeat another 2 times.

### Number

A **Number** value can represent a number, including integers (whole numbers) and decimal numbers.
**Numbers** can work differently in different programming languages but, in Scratch, [Variables](#variables) with a **Number** value can be either an integer (whole number) or a decimal value.

### Operators

**Operators** are another [Computational Concept](#computational-concept), which refer to the mathematical, logical and [String](#string) expressions that can be used when [Coding](#coding).
As [Brennan and Resnick](http://web.media.mit.edu/~kbrennan/files/Brennan_Resnick_AERA2012_CT.pdf){:target="_blank"} describe, *"Scratch supports a range of mathematical operations (including addition, subtraction, multiplication, division, as well as functions like sine and exponents) and string operations (including concatenation and length of strings)."*

Examples of different **Operators** blocks are shown in the blocks below:

~~~
(5) + (10)

(30) / (2)

length of [world]

[sqrt v] of (9)
~~~
{: .language-scratch}


### Pair Programming

**Pair Programming** involves having students work on [Coding](#coding) projects together on one computer, usually in pairs of two.
This approach can help encourage collaboration between students when they are learning [Computational Thinking](#computational-thinking).

There are two main roles in **Pair Programming**: the *driver* and the *observer/navigator*.
The *driver* usually creates the Code (e.g. by dragging and dropping blocks into Scratch), while the *observer/nagivator* talks them through creating the Code and reviews what they have created.
Pair programmers often switch between these two roles when working on [Coding](#coding) together.

[This video from the Code.org website](https://www.youtube.com/watch?v=vgkahOzFH2Q){:target="_blank"} shows an example of how **Pair Programming** can be used in a classroom.

### Parallelism

**Parallelism** is another [Computational Concept](#computational-concept), which refers to [Sequences](#sequences) of instructions that are followed by a computer at the same time.
An example of **Parallelism** in Scratch described by [Brennan and Resnick](http://web.media.mit.edu/~kbrennan/files/Brennan_Resnick_AERA2012_CT.pdf){:target="_blank"} could be a dance party scene, where multiple [Sprites](#sprite) are dancing different dances at the same time.

A single [Sprite](#sprite) can perform instructions in parallel, as illustrated in the blocks below.
After clicking the green flag in Scratch, a [Sprite](#sprite) with the following blocks would do a dance, play a melody and say "Hello!", then "Goodbye!", all at the same time.

~~~
when gf clicked:
	forever
		move (50) steps
		wait (1) secs
		move (-50) steps
		wait (1) secs
	end

when gf clicked:
	forever
		play note (60 v) for (1) beats
		play note (62 v) for (1) beats
		play note (64 v) for (1) beats
		play note (66 v) for (1) beats
	end

when gf clicked:
	forever
		say [Hello!] for (2) secs
		say [Goodbye!] for (2) secs
	end

~~~
{: .language-scratch}


### Program

A **program** is *Code* that has been written to perform one or more different tasks.
For example, in the Week 1 session you created a **program** where you tell a Cat [Sprite](#sprite) how many times to dance.
Another (more complicated) example is a **program** like *Microsoft Word*, which can perform many different tasks (for example: bolding text and making tables)
A **program** differs from an [Algorithm](#algorithm) in that an [Algorithm](#algorithm) does not necessarily need to be written in some [Coding](#coding) language.
When we refer to a **program**, we mean that the instructions for the computer to follow have been written in a [Coding](#coding) language (for example: Scratch).

### Programming

See the definition of [Coding](#coding) above.

### Remixing

**Remixing** is a [Computational Practice](#computational-practice), which refers to the practice in Scratch, and [Coding](#coding) more generally, of taking copies of [Programs](#program) and modifying them.
A similar term to **Remixing** is *Modding* - where Coders take an existing [Program](#program) (such as a game) and make customisations to that [Program](#program).

**Remixing** in Scratch is common because you can use the *remix* button once inside a project to copy all of a project's [Sprites](#sprite) and [Scripts](#scripts). 
The Scratch Wiki has a [page on Remixing in Scratch](https://en.scratch-wiki.info/wiki/Remix){:target="_blank"}, which explains how you can *remix* a project and some of the potential issues with **Remixing** in the Scratch community (such as plagiarism of others' work).

### Repetition

See the definition of [Loops](#loops) above.

### Reset

In [Coding](#coding), you may often want to **Reset** a program by making the [Sprites](#sprite) return to their original position and [Variables](#variables) return to their original value. 
For example, in Scratch you could make an animation where a [Sprite](#sprite) starts in the centre of the [Stage](#stage) and moves to the right. 
After the animation finishes, the [Sprite](#sprite) will no longer start at the centre unless you tell it to move back to the centre.
You could do this by using a **Reset** or a *setup script*, which could be followed when the *green flag* button is clicked.

An example of a **Reset** script is shown below, which will move a [Sprite](#sprite) back to its original position in the centre of the [Stage](#stage) after the *green flag* button is clicked.

~~~
when gf clicked
	go to x: (0) y: (0)
~~~
{: .language-scratch}

### Selection

See the definition of [Conditionals](#conditionals) above.

### Sequences

**Sequences** are a [Computational Concept](#computational-concept), which refers to the way that computers follow instructions in order.
When writing [Algorithms](#algorithm), it is important to order instructions in the correct order, as computers will follow them exactly as we tell them.

An example of why **Sequences** are important is given on the [BBC Bitesize Website](https://www.bbc.co.uk/education/guides/zsf8d2p/revision){:target="_blank"}.
An [Algorithm](#algorithm) for brushing your teeth could be:

1. put toothpaste on toothbrush
2. use toothbrush to clean teeth
3. rinse toothbrush

But what if these steps were in the wrong order (out of **sequence**)?

1. use toothbrush to clean teeth
2. put toothpaste on toothbrush
3. rinse toothbrush

If we gave a robot these instructions, it would follow them in the specified order without questioning.
Consequently, the toothpaste would be wasted and the robot's teeth wouldn't be cleaned properly, as they have not brushed their teeth with toothpaste on the toothbrush.

### String

A **String** in *Coding* is a piece of text, of any length.
For example: both *Hello World* and *Bob* are **Strings**.
[Variables](#variables) that have some text value (for example: a [variable](#variables) called *username*) consequently have a value of the **String** type.

### Testing

**Testing** is the process of checking that a [Program](#program) works as you expect it to.
When you are writing [Programs](#program) it can be important to test to find out if there are any *bugs* (see [Debugging](#debugging)).

For example, you may write the following [Program](#program) to calculate the area of a rectangle:

~~~

when gf clicked
	ask [What is the width of the rectangle?] and wait
	set [width v] to (answer)
	ask [What is the height of the rectangle?] and wait
	set [height v] to (answer)
	set [area] to ((width) * (height))
	say (join [The area of the rectangle is:] (area))
~~~
{: .language-scratch}

You could test this by answering the [Sprite's](#sprite) questions with different *heights* and *widths* and seeing that you get the expected *area*.
You may also test some [Invalid Input](#invalid-input), such as 0 and -1, and you would find that you could get a resulting *area* that doesn't make sense.
For example, if you put in the *height:* 5 and *width*: -1 then you will get an *area* of -5 (which is not possible!).
After finding this bug, you could then change the [Program](#program) to check for negative numbers and not let the user put these in.

### User Input

**User Input** is a term that means that the person using the [Program](#program) (*the user*) interacts with the [Program](#program), usually by (but not always) using a keyboard/mouse.
For example, you might register for an event (for example: a workshop) using an online form. 
The **User Input** in this example would be the details you would enter into the form (such as your name and email address).
Another example of **User Input**  is controlling a character in a videogame with a joystick. 
The videogame would have some *Code* that would take that input from the joystick (for example: moving the joystick to the right) and then performing some action (in this example: moving the character to the right).

### Variables

**Variables** in [*Coding*](#coding) are names given to values that can change.
For example, you could *Code* a game where you have to shoot aliens and you might have a **Variable** in the game *Code* called *score*.
Every time you shoot an alien this *score* **Variable** could increase by 1.

**Variables** in Mathematics and Coding are similar, in that they both are a name/letter that can represent a number.
However, in Coding a **Variable** can also represent a piece of text (a *String* value).
There are also some other differences in how **Variables** can be used in Coding.
For example, a statement like the equation below is perfectly fine in some [*Coding*](#coding) languages, but doesn't make sense in Mathematics:

*x = x + 1*

In Maths this would mean that x is equal to x plus 1 (but this does not make sense).
In [*Coding*](#coding), this means that the value of x will change to x plus 1 (so if x was 2, it would be 3 after the statement above). 

Different [*Coding*](#coding) languages handle the changing of variables in different ways.
In Scratch, for example, we would write the example statement above as:

~~~
change [x v] by (1)
~~~
{: .language-scratch}

### Vector

A **Vector** image is one of the two types of images (the other type of images are [Bitmap](#bitmap) images). 
**Vector** images are made up of shapes and coordinates and are often used for images that need to be scaled to a variety of different sizes (such as logos and graphs).

You may notice that when you resize a **Vector** image it does not become blurry or pixelated, like a [Bitmap](#bitmap) image would.
This is because of the way the **Vector** images are stored as objects and co-ordinates, rather than as pixels in a grid.

The Paint Editor in Scratch has the ability to create **Vector** and [Bitmap](#bitmap) images, which is explained on the [Scratch Wiki](https://en.scratch-wiki.info/wiki/Paint_Editor){:target="_blank"}.
You can learn more about **Vector** and [Bitmap](#bitmap) images and the differences between them from [this page about Encoding Images on the BBC Bitesize Website](https://www.bbc.com/education/guides/zqyrq6f/revision/1){:target="_blank"}.

### Visual Programming

**Visual Programming** refers to forms of [Coding](#coding) where Code can be created and edited by manipulating graphics.
An example of a **Visual Programming** language is *Scratch*, in which you can drag and drop coloured blocks into stacks to create programs. 

**Visual Programming** languages are different to *Text Languages* (such as *Python* or *Java*), where Code is written out in Text instead of dragging and dropping blocks.
In the [Digital Technologies curriculum](https://www.australiancurriculum.edu.au/f-10-curriculum/technologies/digital-technologies/?year=12985&strand=Digital+Technologies+Knowledge+and+Understanding&strand=Digital+Technologies+Processes+and+Production+Skills&capability=ignore&capability=Literacy&capability=Numeracy&capability=Information+and+Communication+Technology+%28ICT%29+Capability&capability=Critical+and+Creative+Thinking&capability=Personal+and+Social+Capability&capability=Ethical+Understanding&capability=Intercultural+Understanding&priority=ignore&priority=Aboriginal+and+Torres+Strait+Islander+Histories+and+Cultures&priority=Asia+and+Australia%E2%80%99s+Engagement+with+Asia&priority=Sustainability&elaborations=true&elaborations=false&scotterms=false&isFirstPageLoad=false){:target="_blank"}, ACARA encourages the teaching of **Visual Programming** in years 5 and 6.

Examples of other **Visual Programming** languages include [GP Blocks](https://gpblocks.org/){:target="_blank"} and [Snap! Build your Own Blocks](https://snap.berkeley.edu/){:target="_blank"}.

## Scratch Terms

### Backpack

The **Backpack** is a feature in the online version of Scratch, which allows you to copy [Costumes](#costumes), [Sprites](#sprites), Sounds, and Scripts between different projects.
This feature is useful when you have a useful script in one project and you don't want to create this script "from scratch" in another project.

In the editor view of Scratch, you can drag and drop the [Costumes](#costumes), [Sprites](#sprites), Sounds, and Scripts into the **Backpack**.
Then, when you are in the project you want to copy the objects to, you can drag them out of the **Backpack**.

You can read more about the **Backpack** feature in Scratch on [this page of the ScratchWiki](https://en.scratch-wiki.info/wiki/Backpack){:target="_blank"}.

### Block

A *command* which tells the [Sprite](#sprite) what to do.
When a **block** is clicked, the [Sprite](#sprite) will follow that instruction.

### Broadcasting

**Broadcasting** in Scratch is used to send messages between [Sprites](#sprite).
This can be useful when you need to have some interactions between two or more [Sprites](#sprite).
For example, you can use **Broadcasting** for creating a conversation between two [Sprites](#sprite).

An example of the application of **Broadcasting**, which uses *broadcast* and *when I receive* blocks, for a conversation between two [Sprites](#sprite) is shown below.

Say that we have the following conversation between two [Sprites](#sprite): a *Cat* and a *Dog*.

*Cat: Hey Dog!*

*Dog: Hey Cat! How's it going?*

*Cat: I'm good, thanks!*

*Dog: That's great, let's go to class!*

The blocks for the *Cat* could look like this:

~~~

when gf clicked
	say [Hey Dog!] for (2) secs
	broadcast [message1 v]

when I receive [message2]
	say [I'm good, thanks!] for (2) secs
	broadcast [message3 v]

~~~
{: .language-scratch}

Then, the blocks for the *Dog* could look like this:

~~~
when I receive [message1 v]
	say [Hey Cat! How's it going?] for (2) secs
	broadcast [message2 v]

when I receive [message3 v]
	say [That's great, let's go to class!] for (2) secs

~~~
{: .language-scratch}

### Costumes

Are alternative ways that a [Sprite](#sprite) can look on the stage.

### Custom Block

A **Custom Block** in Scratch is a special type of [Block](#block) in Scratch, which are located in the *More Blocks* section of the Blocks Pane.
You can create your own *Custom Blocks*, which are useful for putting stacks of blocks that are frequently used into a single [Block](#block).

To create a **Custom Block**, you use the *Make a block* button.
The *Make a block* button creates a *define* [Block](#block), which you place other blocks underneath to be followed when the **Custom Block** is clicked or followed by the Sprite.

An example of where the use of **Custom Blocks** can be useful is explained in the next part of this section.

The blocks below will cause a [Sprite](#sprite) to move upwards and then downwards (do a jump).

~~~

repeat (20)
	change y by (1)
	wait (0.2) secs
end
repeat (20)
	change y by (-1)
	wait (0.2) secs
end

~~~
{: .language-scratch}

You may create a game or animation where a [Sprite](#sprite) jumps and use the same Code in a few different spots in its Scripts.
Instead of duplicating the blocks above a few times, you could make the Code that makes the [Sprite](#sprite) perform the jump into a **Custom Block**.
A **Custom Block** that would do this in Scratch is shown below.
Note that the name of the **Custom Block** is *jump* and that the blocks we want the Sprite to follow are snapped underneath the purple hat block (the *define* block).

~~~

define jump
repeat (20)
	change y by (1)
	wait (0.2) secs
end
repeat (20)
	change y by (-1)
	wait (0.2) secs
end

~~~
{: .language-scratch}

By defining the *jump* **Custom Block**, we can now use these in a few different places.
For example, say that we wanted to make the [Sprite](#sprite) jump whenever the *up arrow*, *space bar* or the *w* are pressed.
This could be achieved by using the following Code in Scratch:

~~~

when [up arrow v] key pressed
	jump :: custom
	
when [space v] key pressed
	jump :: custom

when [w v] key pressed
	jump :: custom

~~~
{: .language-scratch}

The effective use of **Custom Blocks** can make Scratch projects easier to read and have less repetition of Code.
**Custom Blocks** are based off a concept in [Coding](#coding) called *Procedures* and/or *Functions*, which are important concepts in many Coding languages.

### Hat Block

**Hat blocks** are always placed at the top of a stack of blocks.
They are referred to as **hat blocks** because they are shaped like hats.
Some examples of **hat blocks** in Scratch are shown below:

~~~
when gf clicked

when [space v] key pressed

when this sprite clicked
~~~
{: .language-scratch}

### Move

A command which makes the [Sprite](#sprite) change its position, which is in the *Motion* section.
A **move** block, which will **move** a [Sprite](#sprite) 50 steps (pixels) is shown below:

~~~
move (50) steps
~~~
{: .language-scratch}


### Next costume

A command which switches to the **next costume** in the list of the [Sprite's](#sprite) costumes, which is in the *Looks* section.
The **next costume** after the last one is the first one in the list again.
A **next costume** block is shown below:

~~~
next costume
~~~
{: .language-scratch}

### Repeat block

A **repeat block** is a block which runs the blocks inside it a specified number of times, which is in the *Control* section.
The following **repeat block** in Scratch will play a note 10 times:

~~~
repeat (10)
	play note (60 v) for (2) beats
end
~~~
{: .language-scratch}

### Sensing

**Sensing** is a category of blocks in Scratch, which are all coloured light blue.
The blocks in the **Sensing** category have a variety of effects, mostly related to the detection of different features in the project.
For example, you can use the *touching?* block to detect when two [Sprites](#sprite) are touching each other.

**Sensing** blocks are often combined with [conditionals](#conditionals) in [programs](#program).
For example, you may create a game in Scratch where a Spaceship dodges a bullet fired by an enemy spaceship.
The *touching?* block below, which could be in the Spaceship's Scripts, is used to make the Spaceship say "You lost!" when the bullet collides with the Spaceship.

~~~
if <touching [bullet v] ?> then
	say [You lost!] for (2) secs
end
~~~
{: .language-scratch}

You can read about the different types of **Sensing** blocks [on this page on the Scratch Wiki](https://en.scratch-wiki.info/wiki/Sensing_Blocks){:target="_blank"}

### Script

A **script** is a sequence of blocks snapped together, a program.
It can be run by clicking on any part of the script.

### Sprite

A **sprite** is an object we control using our blocks and scripts.
For example, the Cat in the [Dancing Cat program](https://scratch.mit.edu/projects/173543499/){:target="_blank"} is a **sprite**.

### Stage

The **Stage** is the area where you can see the [Sprites](#sprite).

### Stamp

A **stamp** block is a block which tells the [Sprite](#sprite) to print its image on the stage, which is in the *Pen* section.
A **stamp** block is shown below:

~~~
stamp
~~~
{: .language-scratch}

### Turn

The **turn** block is a command which makes the [Sprite](#sprite) change its direction, which is in the *Motion* section.
An example of a **turn** block, which would cause a [Sprite](#sprite) to rotate clockwise by 90 degrees.

~~~
turn cw (90) degrees
~~~
{: .language-scratch}

### Wait

The **wait** block is a command which waits a specified number of seconds, e.g. 1, 2 or 0.2, then continues with the next blocks. 
The **wait** block is in the *Control* section of blocks.
An example of a wait block is shown in the stacks below.
After clicking this stack of blocks in the example below, the [Sprite](#sprite) would move 20 steps in one movement, wait for 2 seconds and then move another 20 steps in another movement.

~~~
move (20) steps
wait (2) secs
move (20) steps
~~~
{: .language-scratch}
